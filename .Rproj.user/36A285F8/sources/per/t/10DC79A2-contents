library(sp)
library(imputeTS)
library(ggplot2)
library(ggmap)
library(data.table)
library(cowplot)
library(corrplot)
library(summarytools)
library(dplyr)
library(MASS)
library(purrr)
library(RColorBrewer)
library(tibble)
library(tidyr)
library(ggpubr)
library(egg)
library(grid)
library(kableExtra)
library(magrittr)
library(gt)
library(webshot2)
library(xtable)
library(knitr)
library(tinytex)
library(stringr)
library(ggpmisc)
library(ggtext)
library(fs)
library(stringi)
library(jsonlite)
library(shinyjs)
library(tools)
library(assertthat)
library(plotrix)
library(rlang)
library(shinydashboard)
library(shinythemes)
library(broom)
library(reactable)
library(Hmisc)
library(stats)
library(gtable)
library(shinydashboardPlus)
library(shinyWidgets)
library(rhandsontable)
library(rio)
library(janitor)
library(flextable)
library(lubridate)
library(shiny)

# Increase upload size limit:
options(shiny.maxRequestSize = 100*1024*1024)  # 100 MB

# Load external functions:
source('DLCAnalyzer_Functions_final.R')

## Define UI for the Shiny app:
ui <- fluidPage(
  useShinyjs(),
  tags$head(
    tags$style(HTML("hr {border-top: 1px solid #000000;}"),
               HTML(".shiny-notification {
                                              position:fixed;
                                              top: calc(10%);
                                              left: calc(33%);
                                              font-size: 150%;
                                              border: black 1px solid;
                                              background-color: #f7f2d9;
                                              width: 28%;}"
               ))
  ),
  div(style="padding: 1px 0px; width: '100%'",
      titlePanel(
        fluidRow(
          column(1,
                 img(src="Abimael_3000.jpeg",
                     width = 120,
                     height = 150,
                     class = "pull-right"
                 )),
          column(10,
                 h1("The Abimael Laboratory of Neurometabolism")),
          br(),
          br(),
          h4(tags$i("We want to beat disability"))  # This text is italicized by using tags$i
        )
      )
  ),
  
  fluidRow(
    column(12,
           hr(),
           h2("Mouse behavior analysis", style = "color:blue")
    )
  ),
  
  sidebarLayout(
    sidebarPanel(
      width= 2,
      numericInput("num_groups", "Number of Groups:", 2, min = 1),
      uiOutput("groupNamesInputs"),
      uiOutput("fileInputs"),
      # Center the button in the sidebar
      div(style = "text-align: center;",
          actionButton("runMovementAnalysis", "Run Analysis", style = "color: white; background-color: blue; width: 50%")
      )
    ),
    
    mainPanel(
      # Use tabsetPanel to create tabs
      tabsetPanel(
        tabPanel("Metrics (mice area, length, etc.)",
                 # Place the elements for Metrics analysis here
                 plotOutput("resultsPlots"),
                 div(id = "downloadPlotsDiv", downloadButton("downloadPlots", "Download Plots")),
                 tableOutput("resultsTable"),
                 div(id = "downloadTableDiv", downloadButton("downloadTable", "Download Results Table"))
        ),
        tabPanel("Movement metrics (speed, distance, etc.)",
                 plotOutput("movementPlots_2"),
                 div(id = "downloadPlotsDiv_2", downloadButton("downloadPlots_2", "Download Plots")),
                 tableOutput("resultsTable_2"),
                 div(id = "downloadTableDiv_2", downloadButton("downloadTable_2", "Download Results Table"))
        ),
        # Movement metrics tab
        tabPanel("Tracking",
                 br(),
                 div(id = "downloadtrackingPlotsDiv", downloadButton("downloadtrackingPlots", "Download tracking plots")),
                 br(),  # Add some space before the new download button
                 div(downloadButton("downloadData", "Download data in csv file")),  # Add the download button for CSV data
                 plotOutput("trackingPlots", height = "1200px")
                 
        )
      ),
      # Adjust the width ratio to give more space to the main panel
      widths = c(3, 9)
    )
  ),
  tags$style(type = "text/css", ".tab-content {overflow-y: scroll;}")
)

server <- function(input, output) {
  
  selected_points <- c("Head")
  selected_zones <- c("center", "periphery")
  
  # Dynamically generate textInput for group names
  output$groupNamesInputs <- renderUI({
    lapply(1:input$num_groups, function(i) {
      textInput(paste0("group_name", i), paste0("Name for Group ", i), value = paste("Group", i))
    })
  })
  
  # Dynamically generate fileInput based on number of groups
  output$fileInputs <- renderUI({
    lapply(1:input$num_groups, function(i) {
      fileInput(paste0("file", i), paste0("Upload Files for ", input[[paste0("group_name", i)]]), multiple = TRUE)
    })
  })
  
  # Initially hide the download buttons
  shinyjs::hide("downloadtrackingPlotsDiv")
  shinyjs::hide("downloadData")
  shinyjs::hide("downloadPlotsDiv_2")
  shinyjs::hide("downloadTableDiv_2")
  shinyjs::hide("downloadPlotsDiv")
  shinyjs::hide("downloadTableDiv")
  
  #original app:
  results_data <- reactiveVal()
  all_plots <- reactiveVal()
  
  all_data <- list()  # To store data from all groups
  
  tracking_plots <- reactiveVal(list())  # Initialize as an empty list
  tracking_data <- reactiveVal()
  
  # Placeholder for movement metrics analysis results
  movement_data <- reactiveVal()
  movement_plots <- reactiveVal()
  
  movement_data_list <- list() # List to store data for movement metrics from all groups
  
  
  observeEvent(input$runMovementAnalysis, {
    req(input$num_groups)
    all_plots_list <- list()
    all_analysis_results <- list()
    
    for (i in 1:input$num_groups) {
      files <- input[[paste0("file", i)]]
      
      if (!is.null(files)) {
        groupName <- input[[paste0("group_name", i)]]
        TrackingAll <- RunPipeline(files$datapath, FUN = pipeline)
        
        #original app:
        results <- apply_all_functions(TrackingAll)
        results$df$group <- groupName  # Assign the group name to the data
        all_data[[groupName]] <- results$df  # Store data from each group
        
        #test
        report <- generate_report(TrackingAll)
        report$Report$group <- groupName # Add group name to the stats
        movement_data_list[[groupName]] <- report$Report # Store stats in the list
        
        #test 2
        group_analysis_result <- analyze_tracking_data(TrackingAll, selected_points, selected_zones, groupName)
        all_analysis_results[[groupName]] <- group_analysis_result$summary
        
        # Generate additional plots for each group and add them to the list
        group_plots <- generate_additional_plots(TrackingAll, groupName)
        all_plots_list <- c(all_plots_list, group_plots)
      }
    }
    
    #original app:
    # Consolidate data
    consolidated_data <- do.call(rbind, all_data)
    print(consolidated_data) # Check the first few rows of the combined data frame
    results_data(consolidated_data[,-1])
    
    # Generate combined plots
    df <- consolidated_data  # Using 'df' for clarity in the boxplot code
    
    # Boxplot code
    all_plots(lapply(names(df[, sapply(df, is.numeric) & !grepl("sd|sem", names(df))]), function(x) {
      y_label <- switch(x,
                        area  = "Mouse Area (cm2)",
                        length = "Mouse Length (cm)",
                        Front_paw_distance_mean = "Front Paw Distance (cm)",
                        Back_paw_distance_mean = "Back Paw Distance (cm)",
                        mean_stride_length = "Stride Length (cm)",
                        Stride_length_left_mean = "Stride Length Left (cm)",
                        step_width = "Step Width (cm)",
                        x)
      
      plot <- ggplot(df, aes(x = group, y = df[[x]], color = group)) +
        geom_boxplot(width = 0.4) +
        geom_jitter(width = 0.2, alpha = 0.5, size = 3) +
        labs(x = "", y = y_label) +
        scale_color_manual(values = c("Control" = "dodgerblue", "Mutant" = "red"))
      
      if (length(unique(df$group)) == 2 && all(table(df$group) >= 3)) {
        plot + stat_compare_means(method = "t.test", label = "p.signif")
      } else if (length(unique(df$group)) > 2 && all(table(df$group) >= 3)) {
        anova_result <- aov(df[[x]] ~ group, data = df)
        anova_summary <- summary(anova_result)
        p_value <- anova_summary[["Pr(>F)"]][1]
        adjusted_p_value <- p.adjust(p_value, method = "bonferroni")
        # Adjust the position of the annotation
        plot + annotate("text", x = 1, y = max(df[[x]], na.rm = TRUE),
                        label = paste("Adj. p:", round(adjusted_p_value, 3)),
                        hjust = -0.1, vjust = 2)
        
      } else {
        plot
      }
    }))
    
    
    
    
    # Combine stats from all groups
    combined_movement_stats <- do.call(rbind, movement_data_list)
    print(combined_movement_stats) # Check the first few rows of the combined data frame
    movement_data(combined_movement_stats[, c(ncol(combined_movement_stats), 1:(ncol(combined_movement_stats)-1))])
    
    
    #test
    # Generate combined plots for movement metrics
    combined_movement_plots <- lapply(names(combined_movement_stats[, sapply(combined_movement_stats, is.numeric)]), function(x) {
      y_label <- switch(x,
                        "Tailbase.raw.distance" = "Distance moved (cm)",
                        "Tailbase.speed.moving" = "Speed (cm/s)",
                        "Tailbase.distance.moving" = "Distance moving (cm)",
                        "Tailbase.time.moving" = "Time moving (s)",
                        "Tailbase.raw.speed" = "Raw speed (cm/s)",
                        "Tailbase.total.time" = "Total time (s)",
                        "Tailbase.time.stationary" = "Time not moving (s)",
                        "Tailbase.percentage.moving" = "% moving",
                        x)
      plot <- ggplot(combined_movement_stats, aes_string(x = "group", y = combined_movement_stats[[x]], fill = "group", color = "group")) +
        geom_boxplot(width = 0.4) +
        geom_jitter(width = 0.2, alpha = 0.5, size = 3) +
        labs(x = "", y = y_label)+
        scale_color_manual(values = c("Control" = "dodgerblue", "Mutant" = "red"))
      
      if (length(unique(combined_movement_stats$group)) == 2 && all(table(combined_movement_stats$group) >= 3)) {
        plot + stat_compare_means(method = "t.test", label = "p.signif")
      } else if (length(unique(combined_movement_stats$group)) > 2 && all(table(combined_movement_stats$group) >= 3)) {
        anova_result <- aov(combined_movement_stats[[x]] ~ group, data = combined_movement_stats)
        anova_summary <- summary(anova_result)
        p_value <- anova_summary[["Pr(>F)"]][1]
        adjusted_p_value <- p.adjust(p_value, method = "bonferroni")
        # Adjust the position of the annotation
        plot + annotate("text", x = 1, y = max(combined_movement_stats[[x]], na.rm = TRUE),
                        label = paste("Adj. p:", round(adjusted_p_value, 3)),
                        hjust = -0.1, vjust = 2)
        
      }else {
        plot
      }
    })
    
    #test 2
    if (length(all_analysis_results) > 0) {
      combined_analysis <- data.frame()
      
      for (groupName in names(all_analysis_results)) {
        combined_analysis <- rbind(combined_analysis, all_analysis_results[[groupName]])
      }
      
      tracking_data(combined_analysis)
      
      combined_analysis_grouped <- combined_analysis %>%
        group_by(group, zone) %>%
        summarise(mean_percentage = mean(percentage), sd_percentage = sd(percentage), .groups = "drop")
      
      combined_analysis_grouped <- combined_analysis_grouped %>%
        mutate(p_value = NA_real_, significance = NA_character_)
      
      all_posthoc_results <- data.frame()  # Initialize an empty dataframe
      
      for (zone_name in unique(combined_analysis$zone)) {
        data_sub <- combined_analysis %>% filter(zone == zone_name)
        
        if (length(unique(data_sub$group)) == 2 && all(table(data_sub$group) >= 3)) {
          t_test_results <- t.test(percentage ~ group, data = data_sub)
          combined_analysis_grouped <- combined_analysis_grouped %>%
            mutate(p_value = if_else(zone == zone_name, t_test_results$p.value, p_value),
                   significance = if_else(zone == zone_name, ifelse(p_value < 0.05, "p < 0.05", "ns"), significance))
        } else if(length(unique(data_sub$group)) > 2) {
          aov_results <- aov(percentage ~ group, data = data_sub)
          if(!is.null(aov_results)) {
            posthoc_results <- TukeyHSD(aov_results, "group")
            if("group" %in% names(posthoc_results)) {
              posthoc_df <- as.data.frame(posthoc_results$group) %>%
                tibble::rownames_to_column(var = "comparison") %>%
                tidyr::separate(comparison, into = c("group1", "group2"), sep = "-") %>%
                dplyr::mutate(zone = zone_name, p_adj_value = p.adjust(`p adj`, method = "bonferroni"))
              
              # Append the results of this zone to the cumulative dataframe
              all_posthoc_results <- rbind(all_posthoc_results, posthoc_df)
            }
          }
        }
      }
      
      print("All posthoc results combined:")
      print(all_posthoc_results)
      
      if (nrow(combined_analysis_grouped) > 0) {
        combined_plot <- ggplot(combined_analysis_grouped, aes(x = zone, y = mean_percentage, fill = group)) +
          geom_errorbar(aes(ymin = mean_percentage - sd_percentage, ymax = mean_percentage + sd_percentage),
                        width = 0.2, position = position_dodge(0.9)) +
          geom_bar(stat = "identity", position = position_dodge(), colour = "black") +
          scale_fill_brewer(palette = "Set1") +
          theme_bw() +
          labs(x = "Zone", y = "Mean Percentage of Frames (%)", fill = "Group") +
          geom_text(aes(label = significance), position = position_dodge(width = 0.9), vjust = -1.5, check_overlap = TRUE) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1))
        
        # Only create the table if more than two groups are compared
        if (length(unique(combined_analysis_grouped$group)) > 2) {
          
          all_posthoc_results <- all_posthoc_results %>%
            dplyr::select(group1, group2, zone, p_adj_value)
          # Create the table grob
          p_value_table <- gridExtra::tableGrob(all_posthoc_results)
          
          # Add the table to the plot
          combined_plot <- combined_plot +
            annotation_custom(grob = p_value_table, xmin = 8, xmax = Inf, ymin = 5, ymax = Inf)
        }
        
        ggsave("combined_group_analysis_plot.pdf", combined_plot, width = 8.5, height = 11)
        all_plots_list <- c(all_plots_list, list(combined_plot))
      } else {
        print("The combined_analysis_grouped data frame is empty.")
      }
    }
    
    movement_plots(combined_movement_plots)
    tracking_plots(all_plots_list)
    
    # Show the download buttons for movement metrics
    shinyjs::show("downloadtrackingPlotsDiv")
    shinyjs::show("downloadData")
    shinyjs::show("downloadPlotsDiv_2")
    shinyjs::show("downloadTableDiv_2")
    shinyjs::show("downloadPlotsDiv")
    shinyjs::show("downloadTableDiv")
  })
  
  # Display the results table
  output$resultsTable <- renderTable({
    req(results_data())
    results_data()
  })
  
  # Original app:
  # Display the plots
  output$resultsPlots <- renderPlot({
    req(all_plots())
    # Use grid.arrange to display all plots in two columns
    do.call(grid.arrange, c(all_plots(), ncol = 3))
  })
  
  # Handle table download
  output$downloadTable <- downloadHandler(
    filename = function() { "results_table.csv" },
    content = function(file) {
      write.csv(results_data(), file)
    }
  )
  
  # Handle plots download
  output$downloadPlots <- downloadHandler(
    filename = function() { "results_plots.pdf" },
    content = function(file) {
      pdf(file)
      do.call(grid.arrange, c(all_plots(), ncol = 2))
      dev.off()
    }
  )
  
  # Outputs for the movement metrics tab
  output$trackingPlots <- renderPlot({
    req(tracking_plots())
    # Combine all the plots into a single grob
    plot_list <- tracking_plots()
    if (length(plot_list) > 0) {
      do.call(gridExtra::grid.arrange, c(plot_list, ncol = 2))
    }
  })
  
  # Download handler for saving the plots as a multi-page PDF
  output$downloadtrackingPlots <- downloadHandler(
    filename = function() {
      "movement_metrics_plots.pdf"
    },
    content = function(file) {
      pdf(file, width = 8.5, height = 11)
      # Retrieve the list of all plots
      plot_list <- tracking_plots()
      
      # Loop over the plots and arrange them
      num_plots <- length(plot_list)
      for (i in seq(1, num_plots, by = 6)) {
        grid.arrange(grobs = plot_list[i:(i + 5)], ncol = 2)
      }
      dev.off()
    }
  )
  
  ## Download handler for the combined_analysis dataframe
  output$downloadData <- downloadHandler(
    filename = function() {"tracking_analysis.csv"},
    content = function(file) {
      write.csv(tracking_data(), file)
    }
  )
  
  # Outputs for the movement metrics tab
  output$movementPlots_2 <- renderPlot({
    req(movement_plots())
    do.call(grid.arrange, c(movement_plots(), ncol = 3))
  })
  
  output$resultsTable_2 <- renderTable({
    req(movement_data())
    movement_data()
  })
  
  # Download handlers for movement metrics
  output$downloadPlots_2 <- downloadHandler(
    filename = function() { "movement_metrics_plots.pdf" },
    content = function(file) {
      pdf(file)
      do.call(grid.arrange, c(movement_plots(), ncol = 3))
      dev.off()
    }
  )
  
  output$downloadTable_2 <- downloadHandler(
    filename = function() { "movement_metrics_table.csv" },
    content = function(file) {
      write.csv(movement_data(), file)
    }
  )
  
}

# Run the app
shinyApp(ui = ui, server = server)
